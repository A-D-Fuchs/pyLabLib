.. _cameras_uc480:

.. note::
    General camera communication concepts are described on the corresponding :ref:`page <cameras_basics>`

Uc480 camera interface
=======================

This is the interface used in multiple cameras, including simple Thorlabs and IDS cameras. It has been tested with IDS SC2592R12M and Thorlabs DCC1545M.

The code is located in :mod:`pylablib.devices.uc480`, and the main camera class is :class:`pylablib.devices.uc480.UC480Camera<.uc480.UC480Camera>`.

Software requirements
-----------------------

These cameras require ``uc480.dll``, which is automatically installed with the freely available `Thorcam <https://www.thorlabs.com/software_pages/ViewSoftwarePage.cfm?Code=ThorCam>`__ tools. By default, the library searches for DLLs in ``Thorlabs/Scientific Imaging/ThorCam`` folder in ``Program Files`` folder (or ``Program files (x86)``, if 32-bit version of Python is running), as well as in the folder containing the script. If the DLLs are located elsewhere, the path can be specified using the library parameter ``devices/dlls/uc480``::

    import pylablib as pll
    pll.par["devices/dlls/uc480"] = "path/to/dlls"
    from pylablib.devices import uc480
    cam = uc480.UC480Camera()


Connection
-----------------------

The cameras are identified by their camera ID or device ID (both starting from 1). Device ID corresponds to the connection order of the cameras: it is guaranteed to be unique, but will change if the camera is disconnected and reconnected again. On the other hand, camera ID is tied to the camera, but it is set to 1 by default for all cameras, and needs to be manually assigned using :meth:`.UC480Camera.set_camera_id`. Alternatively, one can use other characteristics (model or serial number) as a unique identifier. To list all of the connected cameras together with their basic information, you can run :func:`.uc480.list_cameras`::

    >> from pylablib.devices import uc480
    >> uc480.list_cameras()
    [TCameraInfo(cam_id=4, dev_id=1, sens_id=11, model='SC2592R12M', serial_number='1234567890', in_use=False, status=0)]
    >> cam = uc480.UC480Camera(cam_id=4)  # connect to the camera using cam_id
    >> cam.close()
    >> cam = uc480.UC480Camera(dev_id=1)  # connecting to the same camera using dev_id
    >> cam.close()
    >> cam = uc480.UC480Camera()  # connecting to the first available camera
    >> cam.close()

If ``cam_id = 0`` is provided, the software connects to the first available camera.

Operation
------------------------

The operation of these cameras is relatively standard. They support all the standard methods for dealing with ROI and exposure, starting and stopping acquisition, and operating the frame reading loop. However, there's a couple of differences from the standard libraries worth highlighting:

    - Some cameras support both binning (adding several pixels together) and subsampling (skipping some pixels). However, only one can be enabled at a time. They can be set independently using, correspondingly, :meth:`.UC480Camera.get_binning`/:meth:`.UC480Camera.set_binning` and :meth:`.UC480Camera.get_subsampling`/:meth:`.UC480Camera.set_subsampling`. They can also be set as binning factors in :meth:`.UC480Camera.get_roi`/:meth:`.UC480Camera.set_roi`. Whether binning or subsampling is set there can be determined by the ``roi_binning_mode`` parameter on creation.
    - Uc480 API supports many different pixel modes, including packed ones. However, pylablib currently supports only unpacked modes.